# 清除环境中的所有变量
rm(list = ls())

# 确认环境中已经没有变量
print(ls())

# 安装并加载必要的包
if (!requireNamespace("randomForestSRC", quietly = TRUE)) {
  install.packages("randomForestSRC")
}
if (!requireNamespace("survival", quietly = TRUE)) {
  install.packages("survival")
}
if (!requireNamespace("Hmisc", quietly = TRUE)) {
  install.packages("Hmisc")
}
if (!requireNamespace("readxl", quietly = TRUE)) {
  install.packages("readxl")
}
if (!requireNamespace("ggplot2", quietly = TRUE)) {
  install.packages("ggplot2")
}
if (!requireNamespace("caret", quietly = TRUE)) {
  install.packages("caret")
}
if (!requireNamespace("dplyr", quietly = TRUE)) {
  install.packages("dplyr")
}

library(randomForestSRC)
library(survival)
library(Hmisc)
library(readxl)
library(ggplot2)
library(caret)
library(survAUC)
library(dplyr)

# 加载用户数据
file_path <- "C:/Users/fenggu/University of Michigan Dropbox/Feng Gu/GitHub/MachineLearningOnHFData/coxregression.xlsx"  # 请替换为实际路径
user_data <- read_excel(file_path)

# 查看数据
head(user_data)
# 保留所有列除了最后三列
features <- user_data %>% select(-ncol(user_data), -(ncol(user_data)-1), -(ncol(user_data)-2))

# 标准化处理（Z-score）
zscore_normalize <- function(x) {
  (x - mean(x)) / sd(x)
}

# 对所有特征列进行Z-score标准化处理
normalized_data <- as.data.frame(lapply(features, zscore_normalize))

# 处理离群值，将正负2标准差以外的值修正为±2
clip_outliers <- function(x) {
  x[x > 2] <- 2
  x[x < -2] <- -2
  return(x)
}

# 对所有特征列处理离群值
cleaned_data <- as.data.frame(lapply(normalized_data, clip_outliers))

# 添加回原始的最后三列
final_data <- cbind(cleaned_data, user_data %>% select(ncol(user_data)-2, ncol(user_data)-1, ncol(user_data)))
# 定义右截断函数
right_truncate_data <- function(data, time_col, event_col, threshold) {
  truncated_data <- data
  truncated_data[[time_col]] <- pmin(data[[time_col]], threshold)
  truncated_data[[event_col]] <- ifelse(data[[time_col]] > threshold, 0, data[[event_col]])
  return(truncated_data)
}
colnames(final_data)[which(colnames(final_data) == "Time")] <- "time"
colnames(final_data)[which(colnames(final_data) == "Event")] <- "event"
# 使用右截断函数进行处理
threshold <- 3
final_data <- right_truncate_data(final_data, "time", "event", threshold)
# 定义时间单位转换函数
convert_years_to_days <- function(data, time_col) {
  data[[time_col]] <- round(data[[time_col]] * 365)  # 保证天数为整数
  return(data)
}

# 将时间单位从年转换为天
final_data <- convert_years_to_days(final_data, "time")
# 确保列名称正确


# 提取不同特征集合
D <- cbind(final_data[, 1:21], time = final_data$time, event = final_data$event)
M <- cbind(final_data[, c(22:35, 58:61, 63)], time = final_data$time, event = final_data$event)
DM <- cbind(final_data[, c(16, 18, 19, 22:63)], time = final_data$time, event = final_data$event)
# 设定随机数种子以保证每次生成相同的随机数据
set.seed(123)

# 生成新的随机数据替代现有特征（正态分布，均值为0，标准差为1）
generate_random_features <- function(nrows, ncols) {
  return(matrix(rnorm(nrows * ncols, mean = 0, sd = 1), nrow = nrows, ncol = ncols))
}

# 创建新的随机数据框
create_random_data <- function(data, feature_indices, time_col, event_col) {
  nrows <- nrow(data)
  ncols <- length(feature_indices)
  random_features <- generate_random_features(nrows, ncols)
  colnames(random_features) <- colnames(data)[feature_indices]
  random_data <- data.frame(random_features)
  random_data <- cbind(random_data, time = data[[time_col]], event = data[[event_col]])
  return(random_data)
}

# 读取原始数据集（假设final_data已经加载）
# 替代实际数据路径: final_data <- read.csv("path/to/your/data.csv")

# 为D替换新特征
D <- create_random_data(final_data, c(1:21), "time", "event")
# 生成随机数据函数
generate_random_data <- function(n_samples, n_features, time_max) {
  # 生成随机特征
  features <- matrix(rnorm(n_samples * n_features), nrow = n_samples, ncol = n_features)
  feature_names <- paste0("V", 1:n_features)
  features <- as.data.frame(features)
  colnames(features) <- feature_names
  
  # 生成随机时间（生存时间以0到time_max之间的随机数）
  time <- round(runif(n_samples, 0, time_max))  # 包含天数整数
  # 生成随机事件（0或1）
  event <- sample(c(0, 1), n_samples, replace = TRUE)
  
  # 合并数据
  data <- cbind(features, time = time, event = event)
  return(data)
}
# 生成随机数据
n_samples <- 137
n_features <- 6
time_max <- 365 * 3  # 时间范围设为最多3年
D <- generate_random_data(n_samples, n_features, time_max)
# 为M替换新特征
M <- create_random_data(final_data, c(22:35, 58:61, 63), "time", "event")

# 为DM替换新特征
DM <- create_random_data(final_data, c(16, 18, 19, 22:63), "time", "event")
# 创建生存对象
user_surv <- Surv(time = final_data$time, event = final_data$event)


# 加载并调用函数定义文件
source("C:/Users/fenggu/University of Michigan Dropbox/Feng Gu/GitHub/MachineLearningOnHFData/train_and_evaluate_RSF.R")  # 请替换为实际路径
source("C:/Users/fenggu/University of Michigan Dropbox/Feng Gu/GitHub/MachineLearningOnHFData/Coxregression/optimize_rsf_params.R")  # 请替换为实际路径
# 设置超参数网格
# 设置更细致的超参数网格
param_grid <- list(
  ntree = c(50,75,100,150,200),
  mtry = c(1,2,3,4,5,6,7),
  nodesize = c(10,20,30,40,50),
  nodedepth = c(1,2,3,4,5),
  splitrule = c("logrank")
)
opt_D <- optimize_rsf_params(D, param_grid)
opt_M <- optimize_rsf_params(M, param_grid)
opt_DM <- optimize_rsf_params(DM, param_grid)

# 提取详细参数结果
param_results_D <- opt_D$param_results
param_results_M <- opt_M$param_results
param_results_DM <- opt_DM$param_results


# 可视化参数组合与OOB错误率的关系
plot_combination_performance <- function(param_results, dataset_name) {
  ggplot(param_results, aes(x = combination, y = oob_error)) +
    geom_pointrange(aes(ymin = oob_error - oob_error_sd, ymax = oob_error + oob_error_sd), 
                    color = 'blue', size = 0.5) +
    geom_point(color = 'red', size = 2) +
    labs(title = paste("OOB Error Mean and SD for Different Combinations (", dataset_name, ")", sep=""), 
         x = "Combination", y = "OOB Error") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
}

# 绘制每个数据集的组合表现图
plot_D <- plot_combination_performance(param_results_D, "D")
print(plot_D)

plot_M <- plot_combination_performance(param_results_M, "M")
print(plot_M)

plot_DM <- plot_combination_performance(param_results_DM, "DM")
print(plot_DM)



best_params_D <- opt_D$best_params
best_params_M <- opt_M$best_params
best_params_DM <- opt_DM$best_params

# 定义重复次数
reps <- 100

# 初始化结果存储
cindex_results <- data.frame(Model = character(), CIndex = numeric(), stringsAsFactors = FALSE)
brier_results <- data.frame()
auc_results <- data.frame()
iauc_values <- data.frame(Model = character(), iAUC = numeric(), stringsAsFactors = FALSE)

# 运行多次并记录结果
for (i in 1:reps) {
  cat("Iteration:", i, "\n")
  
  results_D <- train_and_evaluate_rsf(D, "D", best_params_D)
  cindex_results <- rbind(cindex_results, data.frame(Model = "D", CIndex = results_D$CIndex))
  brier_results <- rbind(brier_results, results_D$BrierScoreData)
  auc_results <- rbind(auc_results, results_D$AUCData)
  iauc_values <- rbind(iauc_values, data.frame(Model = "D", iAUC = results_D$iAUC))
  
  results_M <- train_and_evaluate_rsf(M, "M", best_params_M)
  cindex_results <- rbind(cindex_results, data.frame(Model = "M", CIndex = results_M$CIndex))
  brier_results <- rbind(brier_results, results_M$BrierScoreData)
  auc_results <- rbind(auc_results, results_M$AUCData)
  iauc_values <- rbind(iauc_values, data.frame(Model = "M", iAUC = results_M$iAUC))
  
  results_DM <- train_and_evaluate_rsf(DM, "DM", best_params_DM)
  cindex_results <- rbind(cindex_results, data.frame(Model = "DM", CIndex = results_DM$CIndex))
  brier_results <- rbind(brier_results, results_DM$BrierScoreData)
  auc_results <- rbind(auc_results, results_DM$AUCData)
  iauc_values <- rbind(iauc_values, data.frame(Model = "DM", iAUC = results_DM$iAUC))
}

# 计算Cindex
summary_results <- aggregate(CIndex ~ Model, data = cindex_results, function(x) c(mean = mean(x), sd = sd(x)))
print(summary_results)

# 计算 Integrative AUC
integrated_auc_values <- aggregate(iAUC ~ Model, data = iauc_values, function(x) c(mean = mean(x), sd = sd(x)))
print("Integrated AUC values:")
print(integrated_auc_values)

# 汇总 Brier Score 和 AUC 数据
brier_summary <- brier_results %>%
  group_by(Model, Time) %>%
  summarize(Mean_BrierScore = mean(BrierScore), SD_BrierScore = sd(BrierScore), .groups = 'drop')

auc_summary <- auc_results %>%
  group_by(Model, Time) %>%
  summarize(Mean_AUC = mean(AUC), SD_AUC = sd(AUC), .groups = 'drop')


# 绘制 Brier Score 随时间变化的图
ggplot(brier_summary, aes(x = Time, y = Mean_BrierScore, color = Model)) +
  geom_line() +
  geom_ribbon(aes(ymin = Mean_BrierScore - SD_BrierScore, ymax = Mean_BrierScore + SD_BrierScore), 
              alpha = 0.2) +
  labs(title = "Brier Score over Time for Different Models", x = "Time", y = "Brier Score") +
  theme_minimal() +
  scale_color_manual(values = c("D" = "blue", "M" = "green", "DM" = "red"))

# 绘制 AUC 随时间变化图
ggplot(auc_summary, aes(x = Time, y = Mean_AUC, color = Model)) +
  geom_line() +
  geom_ribbon(aes(ymin = Mean_AUC - SD_AUC, ymax = Mean_AUC + SD_AUC), 
              alpha = 0.2) +
  labs(title = "AUC over Time for Different Models (survAUC)", x = "Time", y = "AUC") +
  theme_minimal() +
  scale_color_manual(values = c("D" = "blue", "M" = "green", "DM" = "red"))
# 绘制C-index分布图
ggplot(cindex_results, aes(x = Model, y = CIndex)) +
  geom_boxplot() +
  geom_jitter(width = 0.2, alpha = 0.5) +
  labs(title = "C-index Distribution for Different Models", x = "Model", y = "C-index") +
  theme_minimal()
