for (k in 2:max_clusters) {
kproto.result <- kproto(data, k)
# Elbow Method
elbow[k] <- kproto.result$tot.withinss
# DBI
cl_stats <- cluster.stats(daisy(data), kproto.result$cluster)
dbi[k] <- cl_stats$avg.silwidth
# Silhouette Coefficient
sil <- silhouette(kproto.result$cluster, daisy(data))
sil_width[k] <- mean(sil[, 3])
# Calinski-Harabasz Index
ch[k] <- cl_stats$ch
}
return(list(elbow = elbow, dbi = dbi, sil = sil_width, ch = ch))
}
# 执行函数
max_clusters <- 10  # 假设最大聚类数为10
results <- optimal_clusters(user_data_processed, max_clusters)
optimal_clusters <- function(data, max_clusters) {
elbow <- numeric(max_clusters)
dbi <- numeric(max_clusters)
sil_width <- numeric(max_clusters)
ch <- numeric(max_clusters)
for (k in 2:max_clusters) {
kproto.result <- kproto(data, k)
# Elbow Method
elbow[k] <- kproto.result$tot.withinss
# Silhouette Coefficient
sil <- silhouette(kproto.result$cluster, dist(data))
sil_width[k] <- mean(sil[, 3])
# Calinski-Harabasz Index
ch[k] <- cluster.stats(dist(data), kproto.result$cluster)$ch
# DBI
dbi[k] <- index.DB(data, kproto.result$cluster)$DB
}
return(list(elbow = elbow, dbi = dbi, sil = sil_width, ch = ch))
}
# 执行函数
max_clusters <- 10  # 假设最大聚类数为10
results <- optimal_clusters(user_data_processed, max_clusters)
optimal_clusters <- function(data, max_clusters) {
elbow <- numeric(max_clusters)
gap_stats <- numeric(max_clusters)
sil_width <- numeric(max_clusters)
ch <- numeric(max_clusters)
# 计算GAP统计量，需要先定义kproto的wrapper函数
kproto_wrapper <- function(x, k){
km <- kproto(x, k)
list(cluster = km$cluster, tot.withinss = km$tot.withinss)
}
gap <- clusGap(data, FUN = kproto_wrapper, K.max = max_clusters, B = 50)
for (k in 2:max_clusters) {
kproto.result <- kproto(data, k)
# Elbow Method
elbow[k] <- kproto.result$tot.withinss
# Silhouette Coefficient
sil <- silhouette(kproto.result$cluster, daisy(data))
sil_width[k] <- mean(sil[, 3])
# Calinski-Harabasz Index
ch[k] <- cluster.stats(daisy(data), kproto.result$cluster)$ch
# GAP Statistic
gap_stats[k] <- gap$Tab[k, "gap"]
}
return(list(elbow = elbow, gap = gap_stats, sil = sil_width, ch = ch))
}
# 执行函数
max_clusters <- 10  # 假设最大聚类数为10
results <- optimal_clusters(user_data_processed, max_clusters)
optimal_clusters <- function(data, max_clusters) {
elbow <- numeric(max_clusters)
gap_stats <- numeric(max_clusters)
sil_width <- numeric(max_clusters)
ch <- numeric(max_clusters)
# 计算GAP统计量，需要先定义kproto的wrapper函数
kproto_wrapper <- function(x, k){
km <- kproto(x, k)
list(cluster = km$cluster, tot.withinss = km$tot.withinss)
}
gap <- clusGap(data, FUN = kproto_wrapper, K.max = max_clusters, B = 50)
for (k in 2:max_clusters) {
kproto.result <- kproto(data, k)
# Elbow Method
elbow[k] <- kproto.result$tot.withinss
# Silhouette Coefficient
sil <- silhouette(kproto.result$cluster, daisy(data))
sil_width[k] <- mean(sil[, 3])
# Calinski-Harabasz Index
ch[k] <- cluster.stats(daisy(data), kproto.result$cluster)$ch
# GAP Statistic
gap_stats[k] <- gap$Tab[k, "gap"]
}
return(list(elbow = elbow, gap = gap_stats, sil = sil_width, ch = ch))
}
# 执行函数
max_clusters <- 10  # 假设最大聚类数为10
results <- optimal_clusters(user_data_processed, max_clusters)
optimal_clusters <- function(data, max_clusters) {
elbow <- numeric(max_clusters)
gap_stats <- numeric(max_clusters)
sil_width <- numeric(max_clusters)
ch <- numeric(max_clusters)
# 确保输入数据为数据框格式
data <- as.data.frame(data)
# 计算GAP统计量，需要先定义kproto的wrapper函数
kproto_wrapper <- function(x, k){
km <- kproto(x, k)
list(cluster = km$cluster, tot.withinss = km$tot.withinss)
}
gap <- clusGap(data, FUN = kproto_wrapper, K.max = max_clusters, B = 50)
for (k in 2:max_clusters) {
kproto.result <- kproto(data, k)
# Elbow Method
elbow[k] <- kproto.result$tot.withinss
# Silhouette Coefficient
sil <- silhouette(kproto.result$cluster, daisy(data))
sil_width[k] <- mean(sil[, 3])
# Calinski-Harabasz Index
ch[k] <- cluster.stats(daisy(data), kproto.result$cluster)$ch
# GAP Statistic
gap_stats[k] <- gap$Tab[k, "gap"]
}
return(list(elbow = elbow, gap = gap_stats, sil = sil_width, ch = ch))
}
# 执行函数
max_clusters <- 10  # 假设最大聚类数为10
results <- optimal_clusters(user_data_processed, max_clusters)
optimal_clusters <- function(data, max_clusters) {
elbow <- numeric(max_clusters)
sil_width <- numeric(max_clusters)
ch <- numeric(max_clusters)
for (k in 2:max_clusters) {
kproto.result <- kproto(data, k)
# Elbow Method
elbow[k] <- kproto.result$tot.withinss
# Silhouette Coefficient
sil <- silhouette(kproto.result$cluster, daisy(data))
sil_width[k] <- mean(sil[, 3])
# Calinski-Harabasz Index
ch[k] <- cluster.stats(daisy(data), kproto.result$cluster)$ch
}
return(list(elbow = elbow, gap = gap_stats, sil = sil_width, ch = ch))
}
# 执行函数
max_clusters <- 10  # 假设最大聚类数为10
results <- optimal_clusters(user_data_processed, max_clusters)
# 定义kproto的wrapper函数
kproto_wrapper <- function(x, k){
km <- kproto(x, k)
list(cluster = km$cluster, tot.withinss = km$tot.withinss)
}
# 计算GAP统计量
gap_stat <- clusGap(user_data_processed, FUN = kproto_wrapper, K.max = 10, B = 50)
user_data_processed <- as.data.frame(user_data_processed)
# 计算GAP统计量
gap_stat <- clusGap(user_data_processed, FUN = kproto_wrapper, K.max = 10, B = 50)
par(mfrow = c(2, 2))
# Elbow Method
plot(2:max_clusters, results$elbow[2:max_clusters], type="b", xlab="Number of Clusters", ylab="Total Within Sum of Squares", main="Elbow Method")
# Silhouette Coefficient
plot(2:max_clusters, results$sil[2:max_clusters], type="b", xlab="Number of Clusters", ylab="Silhouette Width", main="Silhouette Coefficient")
# Calinski-Harabasz Index
plot(2:max_clusters, results$ch[2:max_clusters], type="b", xlab="Number of Clusters", ylab="Calinski-Harabasz Index", main="CHI")
par(mfrow = c(1, 1))
k <- 4
kproto_result <- kproto(user_data_processed, k)
# 计算Gower距离
gower_dist <- daisy(user_data_processed, metric = "gower")
# 进行层次聚类
hc <- hclust(as.dist(gower_dist), method = "ward.D2")  # 与MATLAB中的"ward"方法对应
# 绘制聚类树
plot(hc, labels = FALSE, main = "Hierarchical Clustering with Gower Distance")
# 提取聚类结果
num_clusters <- 3
clusters <- cutree(hc, k = num_clusters)
# 将聚类结果添加到原数据中
user_data_processed$cluster <- clusters
# 打印数据和聚类结果
print(head(user_data_processed))
evaluate_clusters <- function(data, dist_matrix, max_clusters) {
sil_width <- numeric(max_clusters)
ch_index <- numeric(max_clusters)
for (k in 2:max_clusters) {
hc <- hclust(dist_matrix, method = "ward.D2")
clusters <- cutree(hc, k = k)
# 计算轮廓系数
sil <- silhouette(clusters, dist_matrix)
sil_width[k] <- mean(sil[, 3])
# 计算Calinski-Harabasz指数
ch_index[k] <- cluster.stats(dist_matrix, clusters)$ch
}
return(list(sil = sil_width, ch = ch_index))
}
# 评估不同聚类数目的结果
max_clusters <- 10  # 最大聚类数，可以根据需要调整
results <- evaluate_clusters(user_data_processed, as.dist(gower_dist), max_clusters)
par(mfrow = c(1, 2))
# 轮廓系数
plot(2:max_clusters, results$sil[2:max_clusters], type = "b", xlab = "Number of Clusters", ylab = "Silhouette Width", main = "Silhouette Coefficient")
# Calinski-Harabasz指数
plot(2:max_clusters, results$ch[2:max_clusters], type = "b", xlab = "Number of Clusters", ylab = "Calinski-Harabasz Index", main = "Calinski-Harabasz Index")
# 用数据的前两维进行简单的可视化
fviz_cluster(list(data = user_data_processed, cluster = final_clusters))
# 确定最佳聚类数，例如通过观察上图可以得出最佳的聚类数为4
optimal_clusters <- 2
# 进行最终的层次聚类
hc_final <- hclust(as.dist(gower_dist), method = "ward.D2")
final_clusters <- cutree(hc_final, k = optimal_clusters)
# 用数据的前两维进行简单的可视化
fviz_cluster(list(data = user_data_processed, cluster = final_clusters))
# 或者使用PCA进行二维可视化
fviz_cluster(list(data = user_data_processed, cluster = final_clusters), geom = "point", stand = FALSE)
# 清除环境中的所有变量
rm(list = ls())
# 安装并加载必要的软件包
necessary_packages <- c("clustMixType", "FactoMineR", "factoextra", "cluster", "openxlsx", "fpc")
installed_packages <- rownames(installed.packages())
for (pkg in necessary_packages) {
if (!(pkg %in% installed_packages)) {
install.packages(pkg)
}
library(pkg, character.only = TRUE)
}
# 读取数据
file_path <- "C:/Users/fenggu/University of Michigan Dropbox/Feng Gu/GitHub/MachineLearningOnHFData/test.xlsx"  # 请替换为实际路径
user_data <- readxl::read_excel(file_path)
# 选择第三列到最后一列
user_data_selected <- user_data[, 3:ncol(user_data)]
# 将包含0和1的列转换为因子类型
user_data_processed <- user_data_selected
user_data_processed[] <- lapply(user_data_processed, function(x) {
if (all(x %in% c(0, 1))) {
as.factor(x)
} else {
x
}
})
# FAMD分析
famd_result <- FAMD(user_data_processed, ncp = 10, graph = FALSE)
# 提取主成分结果
principal_components <- as.data.frame(famd_result$ind$coord)
# 定义评估函数
evaluate_clusters <- function(data, max_clusters) {
sil_width <- numeric(max_clusters)
ch_index <- numeric(max_clusters)
for (k in 2:max_clusters) {
hc <- hclust(data, method = "ward.D2")
clusters <- cutree(hc, k = k)
# 计算轮廓系数
sil <- silhouette(clusters, data)
sil_width[k] <- mean(sil[, 3])
# 计算Calinski-Harabasz指数
ch_index[k] <- cluster.stats(data, clusters)$ch
}
return(list(sil = sil_width, ch = ch_index))
}
# 计算Gower距离
gower_dist <- daisy(user_data_processed, metric = "gower")
gower_dist_matrix <- as.dist(gower_dist)
# 评估层次聚类的最佳聚类数目
max_clusters <- 10  # 最大聚类数，可以根据需要调整
hc_results <- evaluate_clusters(gower_dist_matrix, max_clusters)
# 根据轮廓系数或Calinski-Harabasz指数确定最佳聚类数
optimal_clusters_hc <- which.max(hc_results$sil)
optimal_clusters_hc
optimal_clusters_hc
# 进行最终的层次聚类
hc_final <- hclust(gower_dist_matrix, method = "ward.D2")
final_clusters_hc <- cutree(hc_final, k = optimal_clusters_hc)
# K原型聚类 (k-prototypes clustering)
optimal_clusters_kproto <- function(data, max_clusters) {
sil_width <- numeric(max_clusters)
ch_index <- numeric(max_clusters)
for (k in 2:max_clusters) {
kproto_result <- kproto(data, k)
# 计算轮廓系数
sil <- silhouette(kproto_result$cluster, daisy(data))
sil_width[k] <- mean(sil[, 3])
# 计算Calinski-Harabasz指数
ch_index[k] <- cluster.stats(daisy(data), kproto_result$cluster)$ch
}
return(list(sil = sil_width, ch = ch_index))
}
# 评估K原型聚类的最佳聚类数目
kproto_results <- optimal_clusters_kproto(user_data_processed, max_clusters)
# 根据轮廓系数或Calinski-Harabasz指数确定最佳聚类数
optimal_clusters_kproto <- which.max(kproto_results$sil)
optimal_clusters_kproto
# 根据轮廓系数或Calinski-Harabasz指数确定最佳聚类数
optimal_clusters_kproto <- 4
# 进行最终的K原型聚类
kproto_final <- kproto(user_data_processed, optimal_clusters_kproto)
final_clusters_kproto <- kproto_final$cluster
# 创建最终的数据框只包含主成分结果和聚类结果
final_result <- principal_components
final_result$HC_Cluster <- final_clusters_hc
final_result$KProto_Cluster <- final_clusters_kproto
# 创建一个新的Excel工作簿
wb <- createWorkbook()
# 添加一个工作表
addWorksheet(wb, "Clustered Data")
# 写入数据到工作表
writeData(wb, sheet = "Clustered Data", x = final_result)
# 保存Excel文件
saveWorkbook(wb, file = "Final_Clustered_Data.xlsx", overwrite = TRUE)
# 打印完成信息
cat("数据处理及聚类分析已完成，结果已保存至 Final_Clustered_Data.xlsx\n")
source("C:/Users/fenggu/University of Michigan Dropbox/Feng Gu/GitHub/MachineLearningOnHFData/Coxregression/clusterondata.R")
# 进行最终的层次聚类
hc_final <- hclust(gower_dist_matrix, method = "ward.D2")
# 可视化评估结果
par(mfrow = c(1, 2))
# 轮廓系数
plot(2:max_clusters, kproto_results$sil[2:max_clusters], type = "b", xlab = "Number of Clusters", ylab = "Silhouette Width", main = "Silhouette Coefficient (k-prototypes)")
# Calinski-Harabasz指数
plot(2:max_clusters, kproto_results$ch[2:max_clusters], type = "b", xlab = "Number of Clusters", ylab = "Calinski-Harabasz Index (k-prototypes)", main = "Calinski-Harabasz Index (k-prototypes)")
# K原型聚类 (k-prototypes clustering)
evaluate_clusters <- function(data, max_clusters) {
elbow <- numeric(max_clusters)
sil_width <- numeric(max_clusters)
ch <- numeric(max_clusters)
for (k in 2:max_clusters) {
kproto_result <- kproto(data, k)
elbow[k] <- kproto_result$tot.withinss
sil <- silhouette(kproto_result$cluster, daisy(data))
sil_width[k] <- mean(sil[, 3])
ch[k] <- cluster.stats(daisy(data), kproto_result$cluster)$ch
}
return(list(elbow = elbow, sil = sil_width, ch = ch))
}
# 评估K原型聚类的最佳聚类数目
kproto_results <- optimal_clusters_kproto(user_data_processed, max_clusters)
# K原型聚类 (k-prototypes clustering)
optimal_clusters_kproto <- function(data, max_clusters) {
elbow <- numeric(max_clusters)
sil_width <- numeric(max_clusters)
ch <- numeric(max_clusters)
for (k in 2:max_clusters) {
kproto_result <- kproto(data, k)
elbow[k] <- kproto_result$tot.withinss
sil <- silhouette(kproto_result$cluster, daisy(data))
sil_width[k] <- mean(sil[, 3])
ch[k] <- cluster.stats(daisy(data), kproto_result$cluster)$ch
}
return(list(elbow = elbow, sil = sil_width, ch = ch))
}
# 评估K原型聚类的最佳聚类数目
kproto_results <- optimal_clusters_kproto(user_data_processed, max_clusters)
par(mfrow = c(2, 2))
# K原型聚类评估结果
plot(2:max_clusters, kproto_results$elbow[2:max_clusters], type = "b", xlab = "Number of Clusters", ylab = "Total Within Sum of Squares", main = "Elbow Method")
plot(2:max_clusters, kproto_results$sil[2:max_clusters], type = "b", xlab = "Number of Clusters", ylab = "Silhouette Width", main = "Silhouette Coefficient")
plot(2:max_clusters, kproto_results$ch[2:max_clusters], type = "b", xlab = "Number of Clusters", ylab = "Calinski-Harabasz Index", main = "Calinski-Harabasz Index")
# K原型聚类 (k-prototypes clustering)
optimal_clusters_kproto <- function(data, max_clusters) {
elbow <- numeric(max_clusters)
sil_width <- numeric(max_clusters)
ch <- numeric(max_clusters)
for (k in 2:max_clusters) {
kproto_result <- kproto(data, k)
elbow[k] <- kproto_result$tot.withinss
sil <- silhouette(kproto_result$cluster, daisy(data))
sil_width[k] <- mean(sil[, 3])
ch_index[k] <- cluster.stats(daisy(data), kproto_result$cluster)$ch
}
return(list(elbow = elbow, sil = sil_width, ch = ch))
}
# 评估K原型聚类的最佳聚类数目
kproto_results <- optimal_clusters_kproto(user_data_processed, max_clusters)
# K原型聚类 (k-prototypes clustering)
optimal_clusters_kproto <- function(data, max_clusters) {
elbow <- numeric(max_clusters)
sil_width <- numeric(max_clusters)
ch <- numeric(max_clusters)
for (k in 2:max_clusters) {
kproto_result <- kproto(data, k)
elbow[k] <- kproto_result$tot.withinss
sil <- silhouette(kproto_result$cluster, daisy(data))
sil_width[k] <- mean(sil[, 3])
ch[k] <- cluster.stats(daisy(data), kproto_result$cluster)$ch
}
return(list(elbow = elbow, sil = sil_width, ch = ch))
}
# 评估K原型聚类的最佳聚类数目
kproto_results <- optimal_clusters_kproto(user_data_processed, max_clusters)
par(mfrow = c(2, 2))
# K原型聚类评估结果
plot(2:max_clusters, kproto_results$elbow[2:max_clusters], type = "b", xlab = "Number of Clusters", ylab = "Total Within Sum of Squares", main = "Elbow Method")
plot(2:max_clusters, kproto_results$sil[2:max_clusters], type = "b", xlab = "Number of Clusters", ylab = "Silhouette Width", main = "Silhouette Coefficient")
plot(2:max_clusters, kproto_results$ch[2:max_clusters], type = "b", xlab = "Number of Clusters", ylab = "Calinski-Harabasz Index", main = "Calinski-Harabasz Index")
# K原型聚类 (k-prototypes clustering)
optimal_clusters_kproto <- function(data, max_clusters) {
sil_width <- numeric(max_clusters)
ch_index <- numeric(max_clusters)
for (k in 2:max_clusters) {
kproto_result <- kproto(data, k)
# 计算轮廓系数
sil <- silhouette(kproto_result$cluster, daisy(data))
sil_width[k] <- mean(sil[, 3])
# 计算Calinski-Harabasz指数
ch_index[k] <- cluster.stats(daisy(data), kproto_result$cluster)$ch
}
return(list(sil = sil_width, ch = ch_index))
}
# 评估K原型聚类的最佳聚类数目
kproto_results <- optimal_clusters_kproto(user_data_processed, max_clusters)
# 可视化评估结果
par(mfrow = c(1, 2))
# 轮廓系数
plot(2:max_clusters, kproto_results$sil[2:max_clusters], type = "b", xlab = "Number of Clusters", ylab = "Silhouette Width", main = "Silhouette Coefficient (k-prototypes)")
# Calinski-Harabasz指数
plot(2:max_clusters, kproto_results$ch[2:max_clusters], type = "b", xlab = "Number of Clusters", ylab = "Calinski-Harabasz Index (k-prototypes)", main = "Calinski-Harabasz Index (k-prototypes)")
set.seed(42)
# FAMD分析
famd_result <- FAMD(user_data_processed, ncp = 10, graph = FALSE)
# 提取主成分结果
principal_components <- as.data.frame(famd_result$ind$coord)
# 定义评估函数
evaluate_clusters <- function(data, max_clusters) {
sil_width <- numeric(max_clusters)
ch_index <- numeric(max_clusters)
for (k in 2:max_clusters) {
hc <- hclust(data, method = "ward.D2")
clusters <- cutree(hc, k = k)
# 计算轮廓系数
sil <- silhouette(clusters, data)
sil_width[k] <- mean(sil[, 3])
# 计算Calinski-Harabasz指数
ch_index[k] <- cluster.stats(data, clusters)$ch
}
return(list(sil = sil_width, ch = ch_index))
}
# 计算Gower距离
gower_dist <- daisy(user_data_processed, metric = "gower")
gower_dist_matrix <- as.dist(gower_dist)
# 评估层次聚类的最佳聚类数目
max_clusters <- 10  # 最大聚类数，可以根据需要调整
hc_results <- evaluate_clusters(gower_dist_matrix, max_clusters)
# 可视化评估结果
par(mfrow = c(1, 2))
# 轮廓系数
plot(2:max_clusters, hc_results$sil[2:max_clusters], type = "b", xlab = "Number of Clusters", ylab = "Silhouette Width", main = "Silhouette Coefficient")
# Calinski-Harabasz指数
plot(2:max_clusters, hc_results$ch[2:max_clusters], type = "b", xlab = "Number of Clusters", ylab = "Calinski-Harabasz Index", main = "Calinski-Harabasz Index")
par(mfrow = c(1, 1))
# 根据轮廓系数或Calinski-Harabasz指数确定最佳聚类数
optimal_clusters_hc <- 2
# 进行最终的层次聚类
hc_final <- hclust(gower_dist_matrix, method = "ward.D2")
final_clusters_hc <- cutree(hc_final, k = optimal_clusters_hc)
# K原型聚类 (k-prototypes clustering)
optimal_clusters_kproto <- function(data, max_clusters) {
sil_width <- numeric(max_clusters)
ch_index <- numeric(max_clusters)
for (k in 2:max_clusters) {
kproto_result <- kproto(data, k)
# 计算轮廓系数
sil <- silhouette(kproto_result$cluster, daisy(data))
sil_width[k] <- mean(sil[, 3])
# 计算Calinski-Harabasz指数
ch_index[k] <- cluster.stats(daisy(data), kproto_result$cluster)$ch
}
return(list(sil = sil_width, ch = ch_index))
}
# 评估K原型聚类的最佳聚类数目
kproto_results <- optimal_clusters_kproto(user_data_processed, max_clusters)
# 可视化评估结果
par(mfrow = c(1, 2))
# 轮廓系数
plot(2:max_clusters, kproto_results$sil[2:max_clusters], type = "b", xlab = "Number of Clusters", ylab = "Silhouette Width", main = "Silhouette Coefficient (k-prototypes)")
# Calinski-Harabasz指数
plot(2:max_clusters, kproto_results$ch[2:max_clusters], type = "b", xlab = "Number of Clusters", ylab = "Calinski-Harabasz Index (k-prototypes)", main = "Calinski-Harabasz Index (k-prototypes)")
# 进行最终的K原型聚类
kproto_final <- kproto(user_data_processed, optimal_clusters_kproto)
final_clusters_kproto <- kproto_final$cluster
# 根据轮廓系数或Calinski-Harabasz指数确定最佳聚类数
optimal_clusters_kproto <- 5
# 进行最终的K原型聚类
kproto_final <- kproto(user_data_processed, optimal_clusters_kproto)
final_clusters_kproto <- kproto_final$cluster
# 创建最终的数据框只包含主成分结果和聚类结果
final_result <- principal_components
final_result$HC_Cluster <- final_clusters_hc
final_result$KProto_Cluster <- final_clusters_kproto
# 创建一个新的Excel工作簿
wb <- createWorkbook()
# 添加一个工作表
addWorksheet(wb, "Clustered Data")
# 写入数据到工作表
writeData(wb, sheet = "Clustered Data", x = final_result)
# 保存Excel文件
saveWorkbook(wb, file = "Final_Clustered_Data.xlsx", overwrite = TRUE)
# 打印完成信息
cat("数据处理及聚类分析已完成，结果已保存至 Final_Clustered_Data.xlsx\n")
plot(hc_final, labels = FALSE, main = "Hierarchical Clustering Dendrogram")
fviz_screeplot(famd_result)
fviz_famd_ind(famd_result)
fviz_famd_var(famd_result)
fviz_famd_ind(famd_result)
fviz_screeplot(famd_result)
fviz_famd_ind(famd_result)
# 检查并修复行名以确保唯一
row.names(user_data_processed) <- make.names(row.names(user_data_processed), unique = TRUE)
set.seed(42)
# FAMD分析
famd_result <- FAMD(user_data_processed, ncp = 10, graph = FALSE)
# 提取主成分结果
principal_components <- as.data.frame(famd_result$ind$coord)
fviz_screeplot(famd_result)
fviz_famd_ind(famd_result)
source("C:/Users/fenggu/University of Michigan Dropbox/Feng Gu/GitHub/MachineLearningOnHFData/Coxregression/clusterondata.R")
source("C:/Users/fenggu/University of Michigan Dropbox/Feng Gu/GitHub/MachineLearningOnHFData/Coxregression/clusterondata.R")
source("C:/Users/fenggu/University of Michigan Dropbox/Feng Gu/GitHub/MachineLearningOnHFData/Coxregression/clusterondata.R")
